/**
 *
 *                                        CRUD
 *                                    CREATE
 *                                    READ
 *                                    UPDATE
 *                                    DELETE
 *
 *  Чаще всего crud приложения являются web-приложениями.То есть,доступ к БД предоставляется через протоколы HTTP
 *
 *
 *                       Примеры CRUDа для сущности post
 *
 * HTTP метод           URl                      Действие
 * GET                /posts                 Получаем все записи(READ)
 *
 * POST               /posts                 Создаем новую запись(CREATE)
 *
 * GET                /posts/new             HTML форма создания записи
 *
 * GET               /posts/:id/edit         HTML форма редактирования записи
 *
 * GET               /posts/:id              Получаем одну запись(READ0
 *
 * PATCH             /posts/:id              Обновляем запись(UPDATE)
 *
 * DELETE            /pots/:id               Удаляем запись(DELETE)
 *
 *                           Почему именно такие URlы и HTTP методы?
 *                                            |
 *                                           REST
 * REST это паттерн проектирования web приложений
 * REST описывает то,как посредством протокола HTTP должен взаимодействовать клиент с сервером
 * Все взаимодействия с сервером сводятся к 4 операциям-получение данных,добавление новых данных,изменение
 * существующих данных,удаление данных
 * ДЛя каждой из 4 операций используется свой HTTP метод-GET,POST,PATCH,DELETE
 *
 *
 *                                      REST vs CRUD
 *  CRUD-4 базовые функции,используемые при работе с базами данных
 *
 *  REST-паттерн проектирования web приложений.описывает как по протоколу HTTP взаимодействовать с сервером для
 *  чтения,добавления,изменения,удаления данных.Описывает,какие URLы,HTTP методы использовать(но не только это)
 *
 *
 *                                   Паттерн DAO(Data Access Object)
 * Мы хотим вынести логику взаимодействия с БД из самой модели в отдельный класс.Паттерн проектирования,когда
 * отдельный класс занимается взаимодействием с БД для конкретной сущности называется DAO
 *
 * ................................................................................................................
 *
 *                                   HTML формы
 *  В форме <form method="POST"- используется тот http метод который будет использоваться при отправке этой формы
 *  в атрибуте action="/people" адрес на который будут отправляться данные с этой формы
 *  тег <input> создает поле для ввода
 *  label дает понять что вводить в поле
 *  <submit - отправляет все данные при нажатии кнопки
 *
 *
 *
 *  HTML формы в thymeleaf принимают на вход объект для которых была форма создана
 *
 *
 *
 *                                    Аннотация @ModelAttribute
 *Может аннотировать метод или аргумент метода
 *
 *
 * МЕТОД:
 * @ModelAttribute("headerMessage")
 * public String populateHeaderMessage(){
 *     return "Welcome to our website"
 * }
 *В модель в каждом методе текущего контроллера добавляет ключ-значение
 * Используется для добавления тех пар ключ-значение,которые нужны во всех моделях этого контроллера
 * Любая модель из этого контроллера поу молчанию будет иметь значение headerMessage
 *
 *  @ModelAttribute("messageObject")
 *  * public MessageObject populateHeaderMessage(){
 *  *     MessageObject messageObject = new MessageObject();
 *  *     messageObject.setSomeField("Hello!")
 *  *     return messageObject;
 *  * }
 *  *Может добавлять в модель любой объект
 *  * Любая модель из этого контроллера будет по умолчанию иметь значение с ключом "messageObject"
 *  *
 *
 *
 * АРГЕМЕНТ МЕТОДА:
 * @PostMapping()
 * public String create(@ModelAttribute ("person") Person person){
 *     personDAO.save(person)
 *     return "redirect:/people";
 * }
 *
 * Берет на себя создание нового объекта,добавление значений в поля с помощью сеттеров,
 * добавление созданного объекта в модель
 *
 *
 *
 *POST-запрос без полей Person
 * @PostMapping()
 * public String create(@ModelAttribute ("person") Person person){
 * добавляем человека в БД
 * return "successPage";
 *
 * }
 * В модель будет положен новый объект Person со значениями полей по умолчанию(0, null , и тд)
 * ////////////////////////////////////////////////////////////////////////////////////////////////////
 * Адреса в thymeleaf обозначаются "@{ /.... }"
 * Объекты "${.....}"
 *  Поля "*{name}" id="name"
 *..................................................................................................................
 *
 *                            HTML 5 использует только GET и POST
 * Могли бы все делать через POST,но хочется использовать возможности HTTP протокола
 *..................................................................................................................
 * как решается проблема?
 * PATCH,DELETE,PUT запросы передаются с помощью POST запроса,
 * но в скрытом поле _method указывается желаемый HTTP метод
 * ThymeLeaf берет это на себя
 *
 *
 * На стороне Spring приложения проблема решается с помощью фильтра
 * Фильтр-объект который перехватывает все входящие HTTP запросы.
 * В данном случае фильтр для того,что бы смотреть на значение поля _method в поступающих HTTP запросах(если поле есть)
 * Пока сделаем вручную. потом в springboot будет делаться с помощью одной строки в конфиг файле
 * //////////////////////////////////////////////////////////////////////////////////////////////
 *                                     ADD VALIDATION @VALID
 * ///////////////////////////////////////////////////////////////////////////////////////////////
 *
 * Добавили валидатор из репозитория к себе в pom.xml  и теперь используем их для установки правил
 * в нашей модели для корректного введения данных пользователем
 * Больше о аннотациях https://alexkosarev.name/2018/07/30/bean-validation-api/
 *
 * public String newPerson(@ModelAttribute("person") @Valid Person person, BindingResult bindingResult)
 * Добавили аннотацию @Valid что бы проверяла она все ли верно вводится по нашим аннотациям в модели.
 * Если ошибка то она добавляется в BindingResult (он всегда идет после модели которая валидируется)
 * в нем лежат все ошибки валидации объекта персон
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
